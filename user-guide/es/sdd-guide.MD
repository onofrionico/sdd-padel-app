# Manual de usuario: Desarrollo guiado por especificaciones (SDD)

Este manual te gu√≠a a trav√©s de la metodolog√≠a de Specification-Driven Development (SDD) para construir features de software. Aprender√°s a crear SPECs completos que definan **qu√©** construir, PLANs detallados que especifiquen **c√≥mo** implementarlo y buenas pr√°cticas para trabajar de forma efectiva con asistentes de IA a lo largo de todo el ciclo de desarrollo.

---

## üéØ Recomendaci√≥n: Desarrollo iterativo con SDD

### Construcci√≥n progresiva de contexto

Trabajar con **Specification-Driven Development (SDD)** mejora significativamente cuando se documenta de forma iterativa:

- **Features relacionadas**: Al completar una feature, puedes comenzar otra relacionada haciendo referencia a la anterior
- **Contexto acumulativo**: Cada SPEC y PLAN documentado enriquece el contexto del proyecto
- **Aprendizaje del agente**: Desarrollar m√∫ltiples features con este framework permite al agente:
  - Entender mejor la arquitectura del proyecto
  - Mantener consistencia en los patrones de implementaci√≥n
  - Reutilizar soluciones y estructuras previas
  - Reducir el tiempo de especificaci√≥n para features similares

### Beneficios del enfoque iterativo

- **Documentaci√≥n viva**: El historial de SPECs y PLANs funciona como documentaci√≥n evolutiva del proyecto
- **Mejora continua**: Cada iteraci√≥n refina el proceso y la calidad de las especificaciones
- **Conocimiento compartido**: Facilita el onboarding de nuevos desarrolladores al proyecto
- **Trazabilidad**: Mantiene un registro claro de decisiones t√©cnicas y de negocio

> **Recomendaci√≥n**: Organiza las features en carpetas dentro de `specs/` y mant√©n referencias cruzadas entre features relacionadas. Esto crea un grafo de conocimiento que potencia el desarrollo asistido por IA.

### Fomentar preguntas de aclaraci√≥n

Indica al agente que haga preguntas cuando encuentre requisitos ambiguos o poco claros. Esto evita suposiciones y asegura especificaciones m√°s precisas.

**Prompt de ejemplo**:
```
"@spec-template create a spec considering: {your spec definition here}. 
If you encounter any ambiguous requirements, unclear business rules, or 
missing information, please ask me clarifying questions before making 
assumptions. I prefer to provide explicit guidance rather than having 
you infer unclear details."
```

---

## ¬øQu√© es un SPEC?

Un **SPEC** es un documento de especificaci√≥n que define **QU√â** se debe construir, sin entrar en detalles de implementaci√≥n.

### Contenido obligatorio

- **Caso de uso**: Descripci√≥n del problema a resolver y flujos de usuario
- **Requisitos funcionales**: Qu√© debe hacer el sistema
- **Requisitos no funcionales**: Performance, seguridad, escalabilidad
- **Criterios de aceptaci√≥n**: Condiciones que determinan si la soluci√≥n es exitosa
- **Objetivos de negocio**: Objetivos de alto nivel que justifican el desarrollo
- **Manejo de errores**: Comportamiento esperado en situaciones inesperadas

### Principios fundamentales

‚úÖ **Hacer:**
- Revisar constantemente el documento
- Explicar **QU√â** se va a lograr
- Incluir requisitos t√©cnicos de alto nivel

### Recomendaciones

- **Herramientas**: Usa Fury for Development MCP para contexto de plataforma y SDKs o el MCP del namespace backend
- **Referencias**: Incluye documentaci√≥n del proyecto, reglas existentes, im√°genes o capturas de Figma y gu√≠as t√©cnicas relevantes para que el agente entienda el contexto y pueda crear una mejor definici√≥n en el SPEC
- **Modelos sugeridos**: "gpt-5.1-codex", "gpt-5-codex", "gpt-5.1" o "gemini-2.5-pro" (modelos con capacidades de razonamiento y an√°lisis)
- **No incluir** detalles de implementaci√≥n, snippets de c√≥digo o rutas de archivos.
- **Modelos no recomendados**: No usar el modelo "composer-1" de Cursor.

---

## ¬øQu√© es un PLAN?

Un **PLAN** es un documento t√©cnico que define **C√ìMO** se implementar√° la soluci√≥n descrita en el SPEC.

### Contenido obligatorio

- **Dise√±o t√©cnico**: Arquitectura y componentes de la soluci√≥n
- **Implementaci√≥n**: C√≥mo se cubrir√°n los requisitos del SPEC
- **Librer√≠as y dependencias**: Librer√≠as, SDKs y frameworks a utilizar
- **Estructuras de datos**: Modelos de base de datos, esquemas, migraciones
- **Contratos de API**: Bodies de request/response, headers, status codes
- **Estrategia de testing**: Tipos de tests (unitarios, integraci√≥n, e2e) y cobertura esperada
- **Tareas detalladas**: Lista granular de actividades a completar (puede estar en un archivo separado)

### Principios fundamentales

‚úÖ **Si hacer:**
- Cubrir todos los requisitos del SPEC
- Explicar **C√ìMO** se va a lograr
- Detallar la implementaci√≥n espec√≠fica del proyecto
- Incluir tareas con alta granularidad

### Recomendaciones

- **Formato**: Archivo `.md` o herramientas de "plan mode" en IDE/CLI
- **Referencias**: Incluye archivos existentes del proyecto como ejemplos de implementaciones similares
- **Modelos sugeridos**: Usa "claude-sonnet-4.5" o "gpt-5.1-codex" para tareas de coding e implementaci√≥n; "gpt-5.1-codex-mini" para cambios m√°s econ√≥micos; "gpt-5.1" para la creaci√≥n de planes

#### ‚ö†Ô∏è Revisi√≥n cr√≠tica del plan

Una revisi√≥n exhaustiva del plan es **fundamental** antes de comenzar la implementaci√≥n:

- **Completitud de tareas**: Verifica que todas las tareas de implementaci√≥n y testing est√©n presentes
- **Criterios de desarrollo**: Valida el cumplimiento de est√°ndares de c√≥digo, convenciones y buenas pr√°cticas del proyecto
- **Arquitectura**: Revisa que el dise√±o propuesto sea coherente con la arquitectura existente
- **Cobertura de testing**: Confirma que los tests unitarios, de integraci√≥n y e2e est√©n incluidos cuando corresponda
- **Dependencias**: Valida que todas las librer√≠as y SDKs necesarios est√©n identificados y sean correctos
- **Contratos de API**: Verifica que todos los endpoints, requests y responses est√©n definidos
- **Manejo de errores**: Asegura que los escenarios de error y recuperaci√≥n est√©n contemplados
- **Iteraci√≥n**: Revisa y refina el plan hasta que cubra todos los requisitos del SPEC

> **Importante**: Un error o falta de detalle en el plan se propagar√° a la implementaci√≥n. Invertir tiempo en la revisi√≥n evita retrabajos posteriores.

---

## üöÄ ¬øCu√°ndo empezar la implementaci√≥n?

La implementaci√≥n debe comenzar **√∫nicamente** cuando se cumplan los siguientes criterios de calidad:

### Criterios de aprobaci√≥n para iniciar el desarrollo

#### ‚úÖ SPEC validado
- **Revisi√≥n completa**: El SPEC ha sido revisado exhaustivamente
- **Casos de uso cubiertos**: Todos los casos de uso y flujos de usuario est√°n documentados
- **Requisitos claros**: Los requisitos funcionales y no funcionales son espec√≠ficos y medibles
- **Criterios de aceptaci√≥n**: Est√°n definidos y son verificables

#### ‚úÖ PLAN completo
- **Arquitectura definida**: El dise√±o t√©cnico es coherente con el proyecto existente
- **Flujos implementados**: Todos los flujos de datos y de control est√°n especificados
- **Manejo de errores**: Los escenarios de error y recuperaci√≥n est√°n contemplados
- **Testing incorporado**: La estrategia de testing (unitario, integraci√≥n, e2e) est√° definida
- **Tareas granulares**: Todas las tareas de implementaci√≥n est√°n identificadas y priorizadas
- **Dependencias identificadas**: Librer√≠as, SDKs y servicios externos est√°n especificados

### ‚ö†Ô∏è Si los criterios no se cumplen

**NO comiences la implementaci√≥n**. En su lugar:

1. Identifica las √°reas faltantes o incompletas
2. Revisa y completa el SPEC y/o el PLAN seg√∫n corresponda
3. Itera hasta que todos los criterios de aprobaci√≥n se cumplan
4. Vuelve a validar antes de continuar

### Beneficios de esta disciplina

- **Implementaci√≥n eficiente**: El c√≥digo fluye naturalmente siguiendo el plan
- **Menos re-trabajo**: Los errores detectados en la especificaci√≥n son m√°s baratos de corregir
- **Mayor calidad**: El testing se integra desde la fase de dise√±o
- **Mejor estimaci√≥n**: Las tareas granulares permiten un seguimiento de progreso m√°s preciso
- **Reducci√≥n de bugs**: Los edge cases y el manejo de errores se contemplan desde el inicio

> **Regla de oro**: Si tienes dudas sobre la completitud del SPEC o del PLAN, **NO implementes**. Invierte tiempo en aclarar primero. Una hora de planificaci√≥n puede ahorrar horas o d√≠as de correcciones.

---

## Workflow

```
1. SPEC ‚Üí Define QU√â construir (sin implementaci√≥n)
2. PLAN ‚Üí Define C√ìMO construirlo (con implementaci√≥n)
3. Development ‚Üí Ejecuta el plan
```

---

## üìã Uso de los templates

Los templates de SPEC y PLAN ubicados en `specs/templates/` proporcionan una estructura estandarizada para la documentaci√≥n.

### ‚ö†Ô∏è Importante

- **No modificar los templates**: Los archivos en `specs/templates/` deben permanecer sin cambios
- **Copiar y completar**: Crea copias de los templates en la carpeta de la feature espec√≠fica
- **Mantener la estructura**: Respeta las secciones definidas en los templates para mantener la consistencia del proyecto

---

## üí∞ Gesti√≥n de tokens y contexto

### ‚ö†Ô∏è Advertencia sobre consumo de tokens

El proceso de creaci√≥n de SPEC y PLAN puede consumir una cantidad significativa de tokens y de ventana de contexto.

### Recomendaciones para optimizar el consumo

1. **Separar por fases**: Crea chats independientes para cada fase de desarrollo
   - Chat 1: Generaci√≥n del SPEC
   - Chat 2: Generaci√≥n del PLAN (adjuntando el SPEC como referencia)
   - Chat 3: Implementaci√≥n (adjuntando SPEC y PLAN como referencia)

2. **Reutilizar documentaci√≥n**: Los archivos de SPEC y PLAN generados son documentos completos que pueden adjuntarse en nuevos chats
   - Evita repetir todo el contexto en cada conversaci√≥n
   - Reduce significativamente el consumo de tokens
   - Mantiene la coherencia entre fases

3. **Ventajas de separar los chats**:
   - Mayor eficiencia en el uso de tokens
   - Contexto m√°s limpio y enfocado en cada etapa
   - Menor riesgo de alcanzar los l√≠mites de la ventana de contexto
   - Mejor organizaci√≥n del trabajo

> **Tip**: Al iniciar un nuevo chat para implementaci√≥n, adjunta los archivos `spec.md` y `plan.md` generados previamente. Esto provee todo el contexto necesario sin consumir innecesariamente la ventana de contexto.
